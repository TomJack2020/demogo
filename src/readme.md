

# Golang 并发同步机制
sync 包：基于共享内存的同步
核心思想： 通过共享内存来实现 goroutine 之间的同步，即多个 goroutine 访问同一块内存区域时，需要通过锁等机制来保证数据的一致性。

主要类型：

Mutex: 互斥锁，保证同一时刻只有一个 goroutine 可以访问共享资源。
RWMutex: 读写锁，允许多个 goroutine 同时读取共享资源，但写操作需要互斥。
WaitGroup: 等待一组 goroutine 完成。
Once: 保证一段代码只执行一次。
Cond: 条件变量，用于等待某个条件满足。
适用场景：

需要精细控制对共享资源的访问时。
当 goroutine 之间需要频繁地进行同步操作时。
实现一些复杂的同步算法。
channel：基于通信的同步
核心思想： 通过通信来共享内存，goroutine 之间通过 channel 传递数据，从而实现同步。
主要特性：
无缓冲 channel: 发送方必须等待接收方准备好才能发送数据，反之亦然，天然实现了同步。
有缓冲 channel: 可以存储一定数量的数据，发送方可以在缓冲区满之前继续发送，接收方可以在缓冲区为空之前继续接收。
适用场景：
goroutine 之间需要传递数据时。
实现生产者-消费者模型。
实现 pipeline 模式。
两者的关系与选择
互补性： sync 包和 channel 并不是相互排斥的，它们可以结合使用来实现更复杂的并发同步。例如，可以使用 WaitGroup 来等待多个 goroutine 完成，然后通过 channel 来传递结果。
选择依据：
复杂度： channel 的使用方式相对简单，而 sync 包中的同步原语则需要更细致的控制。
性能： 在某些场景下，channel 的性能可能更高，但 sync 包中的某些同步原语在特定的情况下也具有优势。
可读性： channel 的代码通常更加简洁易懂，而 sync 包的代码可能会更复杂。
一般来说，建议优先考虑使用 channel 来实现并发同步，因为 channel 的方式更加自然，也更容易理解。只有在 channel 不能满足需求的情况下，才考虑使用 sync 包中的同步原语。